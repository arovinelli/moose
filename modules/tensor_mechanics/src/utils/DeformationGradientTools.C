//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "DeformationGradientTools.h"

namespace DeformationGradientTools
{

RealVectorValue
computedVnormdV(const RealVectorValue & V)
{
  return V / V.norm();
}

RankFourTensor
computedRdF(const RankTwoTensor & R, const RankTwoTensor & U)
{
  const RankTwoTensor Uhat = U.trace() * RankTwoTensor::Identity() - U;
  unsigned int k, l, m, n, p, q;
  const Real Uhat_det = Uhat.det();

  RankFourTensor dR_dF;
  for (k = 0; k < 3; k++)
    for (l = 0; l < 3; l++)
      for (m = 0; m < 3; m++)
        for (n = 0; n < 3; n++)
        {
          dR_dF(k, l, m, n) = 0.;
          for (p = 0; p < 3; p++)
            for (q = 0; q < 3; q++)
              dR_dF(k, l, m, n) +=
                  R(k, p) * (Uhat(p, q) * R(m, q) * Uhat(n, l) - Uhat(p, n) * R(m, q) * Uhat(q, l));

          dR_dF(k, l, m, n) /= Uhat_det;
        }

  return dR_dF;
}

RankFourTensor
computedFinversedF(const RankTwoTensor & F_inv)
{
  return -F_inv.mixedProductIkJl(F_inv.transpose());
}

RankTwoTensor
computeVelocityGradientLinearApprox(const RankTwoTensor & F, const RankTwoTensor & F_old)
{
  return RankTwoTensor::Identity() - F_old * F.inverse();
}

RankFourTensor
computeDL_DF(const RankFourTensor & DFinv_DF, const RankTwoTensor & F_old)
{
  return -AdditionalTensorTools::R2ijR4jklm(F_old, DFinv_DF);
}

RankTwoTensor
computeDtraceL_DF(const RankFourTensor & DL_DF)
{
  return RankTwoTensor::Identity().initialContraction(DL_DF);
}

Real
computeAreaRatio(const RankTwoTensor & FinvT, const Real & J, const RealVectorValue & N)
{
  return J * (FinvT * N).norm();
}

RankTwoTensor
computeDAreaRatioDF(const RankTwoTensor & FinvT,
                    const RealVectorValue & N,
                    const Real & J,
                    const RankFourTensor & DFinv_DF)
{
  const RealVectorValue Fitr_N = FinvT * N;
  const Real Fitr_N_norm = Fitr_N.norm();
  RankTwoTensor R2temp;
  for (unsigned int l = 0; l < 3; l++)
    for (unsigned int m = 0; m < 3; m++)
    {
      R2temp(l, m) = 0;
      for (unsigned int i = 0; i < 3; i++)
        for (unsigned int j = 0; j < 3; j++)
          R2temp(l, m) += Fitr_N(i) * DFinv_DF(j, i, l, m) * N(j);

      R2temp(l, m) *= J / Fitr_N_norm;
    }

  return J * FinvT * Fitr_N_norm + R2temp;
}

Real
computeAreaIncrementRate(const Real Ltrace, const RankTwoTensor & L, const RealVectorValue & n)
{
  return Ltrace - n * (L * n);
}

RankTwoTensor
computeDAreaIncrementRateDF(const RankTwoTensor & L,
                            const RankTwoTensor & DLtrace_DF,
                            const RankFourTensor & DL_DF,
                            const RealVectorValue & N,
                            const RankTwoTensor & R,
                            const RankFourTensor & DR_DF)
{
  RankTwoTensor R2temp;
  for (unsigned int p = 0; p < 3; p++)
    for (unsigned int q = 0; q < 3; q++)
    {
      R2temp(p, q) = 0;
      for (unsigned int i = 0; i < 3; i++)
        for (unsigned int j = 0; j < 3; j++)
          for (unsigned int k = 0; k < 3; k++)
            for (unsigned int l = 0; l < 3; l++)
              R2temp(p, q) += DR_DF(i, k, p, q) * N(k) * L(i, j) * R(j, l) * N(l) +
                              DR_DF(j, l, p, q) * N(l) * L(i, j) * R(i, k) * N(k) +
                              DL_DF(i, j, p, q) * R(i, k) * N(k) * R(j, l) * N(l);
    }
  return DLtrace_DF - R2temp;
}
} // namespace DeformationGradientTools
